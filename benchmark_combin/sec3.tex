%!TEX root = ../main.tex
\section{Collaborative Verification Framework}

Figure \ref{fig:framework} shows the main procedure of our collaborative verification framework.
The main idea is to accumulate the abstraction models of infeasible counter-example traces during
the verification procedure and reuse the accumulated abstraction models to assist the verification later.

% Our verification framework for batch of uninterpreted programs is presented in Figure \ref{fig:framework}.
% The main idea behind that is taking CEGAR process for each program while maintaining an automata to store
% all the infeasible traces, and such automata can be used to facilitate the remaining program's verification in some way.
% Next we give a detail description for this framework.


% \begin{figure}[!hbt]
% \centering
% \input{section/framework}
% \caption{Collaborative verification framework.}
% \label{fig:framework}
% \end{figure}


\begin{figure}[!hbt]
\centering
\input{section/framework1}
\caption{Collaborative verification framework.}
\label{fig:framework}
\end{figure}


Given a set of programs $\mathcal{S}$ and the initial empty automata $\mathcal{A}_C$
which accumulates the abstraction models, our framework first selects a program $\mathcal{P}$
from $\mathcal{S}$ and abstracts $\mathcal{P}$ to an FSA $\mathcal{A}_\mathcal{P}$.
Then we make a reduction of $\mathcal{A}_\mathcal{P}$ based on $\mathcal{A}_C$, \emph{i.e.},
$\mathcal{A}_{\mathcal{P}} = \mathcal{A}_{\mathcal{P}} \setminus \mathcal{A}_{C}$,
to wipe off those infeasible traces before conducting the CEGAR verification process.
During the trace abstraction-based CEGAR verification,
if $\mathcal{L}(\mathcal{A}_{\mathcal{P}}) = \emptyset$ holds, we can conclude that the
program $\mathcal{P}$ is correct; otherwise, we can get a trace $t$
from $\mathcal{L}(\mathcal{A}_{\mathcal{P}})$. The next step depends on the feasibility of $t$.
If $t$ is feasible, we found a real counter-example and $\mathcal{P}$ is incorrect; otherwise,
we abstract an FSA $\mathcal{A}_{n+1}$ from $t$, and all $\mathcal{A}_{n+1}$'s accepted traces are also
infeasible with the same reason as $t$. Then, the model $\mathcal{A}_\mathcal{P}$ is refined by removing the traces in
$\mathcal{A}_{n+1}$ from $\mathcal{A}_\mathcal{P}$. This refinement continues until the refined $\mathcal{A}_\mathcal{P}$
is empty or a feasible counter-example is found.%\footnote{We do not consider time out here for the sake of brevity}.

When $\mathcal{P}$'s verification is completed, we accumulate the abstraction models of the infeasible traces
and merge them into $\mathcal{A}_C$ for reusing. When verifying the remaining programs, the framework will use $\mathcal{A}_C$
to refine the program abstraction and then employ the CEGAR method to verify the refined model.
During the verification procedure, the framework shares the abstraction models of infeasible traces within the programs
in $\mathcal{S}$ to improve the verification's efficiency.


% %框架算法以及描述

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{minipage}{0.55\textwidth}
	\vspace{-1.5cm}
%\begin{wrapfigure}{l}{0.45\textwidth}
\begin{algorithm}[H]
\caption{$\mathsf{CollaborativeCEGAR}(\mathcal{S})$}
\label{alg:frame}
	\begin{algorithmic}[1] %每行显示行号
		\REQUIRE A set $\mathcal{S}$ of uninterpreted programs.
		\ENSURE Result $\mathcal{R}: \mathcal{S} \rightarrow \{\mathsf{correct}, \mathsf{incorrect}\}$
		\STATE $\mathcal{A}_C \leftarrow \emptyset$
        \WHILE{$\mathcal{S}  \neq \emptyset~\wedge~\mathcal{P} \in \mathcal{S}$}
%        	\STATE $\mathcal{P} \leftarrow \mathsf{Select}(\mathcal{S})$
			\STATE $\mathcal{A}_{\mathcal{P}} \leftarrow \mathsf{FSA}(\mathcal{P}) \setminus \mathcal{A}_C$
			\WHILE {$ \mathcal{L}(\mathcal{A}_{\mathcal{P}}) \neq \emptyset ~\wedge ~ t \in \mathcal{L}(\mathcal{A}_{\mathcal{P}}) $}
%				\STATE $t \leftarrow \mathsf{Select}_t(\mathcal{L}(\mathcal{A}_{\mathcal{P}}))$
				\STATE $(r, T) \gets \mathsf{Feasible}(t)$
				\IF{$r\ is\ \mathsf{True}$}
					\STATE  ${\bf break}$
                \ELSE
					\STATE $\mathcal{A}_t \leftarrow \mathsf{Generalize}(T) $
                	\STATE {$\mathcal{A}_{\mathcal{P}}, \mathcal{A}_C \leftarrow \mathcal{A}_{\mathcal{P}} \setminus \mathcal{A}_t, \mathcal{A}_C \cup \mathcal{A}_t$}
				\ENDIF
                \ENDWHILE
                %\STATE
                \STATE $ \mathcal{S} \leftarrow \mathcal{S} \setminus \{\mathcal{P}\}$
                \IF {$ \mathcal{L}(\mathcal{A}_{\mathcal{P}}) \neq \emptyset $}
                	\STATE  $\mathcal{R}[\mathcal{P}] \leftarrow \mathsf{incorrect}$
				\ELSE
					\STATE $\mathcal{R}[\mathcal{P}] \leftarrow \mathsf{correct}$
				\ENDIF
        \ENDWHILE
        \RETURN $\mathcal{R}$
	\end{algorithmic}
\end{algorithm}
\vspace{-1.7cm}
%\end{wrapfigure}
\end{minipage}
\end{wrapfigure}

Algorithm \ref{alg:frame} shows the whole algorithm of our framework in detail, where $\mathsf{FSA}(\mathcal{P})$
represents the FSA over-approximation model of $\mathcal{P}$. The input is a set of uninterpreted programs.
For each program (Line 3), we carry out the CEGAR verification procedure (Line 4-12) described above.
$\mathcal{A}_C$ is the global abstraction model of infeasible traces that is reused for refining each program's
abstraction before CEGAR. In principle, the trace abstraction (\emph{i.e.}, $\mathsf{Generalize}$ at Line 9) affects
both the effectiveness and efficiency of $\mathcal{P}$'s verification and the effectiveness of the accumulated
abstraction model $\mathcal{A}_{C}$ (Line 10). Algorithm \ref{alg:generalize} shows the details of trace abstraction.


After each program's verification, we check whether the language of $\mathcal{A}_{\mathcal{P}}$ is empty.
The non-emptiness (Line 14) implies that we found a feasible counter-example during the CEGAR process, \emph{i.e.}, $\mathcal{P}$
is incorrect (Line 15). While the emptiness (Line 16) means all traces in $\mathcal{A}_{\mathcal{P}}$ are infeasible and
$\mathcal{P}$ is correct (Line 17). Then we check the next program if the program set is not empty (Line 2).



%\noindent
\subsection{Trace Feasibility Checking and Abstraction}

Algorithm \ref{alg:feasible} shows the feasibility checking of a counter-example trace, which is based on semantics defined in \cite{POPL19,fm}. The basic idea is to convert the input trace $t$ into a coherent trace $t'$ on which the feasibility checking is sound and complete. If $t'$ is infeasible, the semantic transitions calculated during checking can be used for trace generalization (Algorithm \ref{alg:generalize}).

First, the algorithms add ghost variables and statements into $t$ to fix the violation of memoizing requirements \cite{fm}. Then, the algorithm extracts the information to fix the early assume violations. $\mathsf{EarlyAssume}(t)$ returns a set $\mathcal{E}_t$ each element of which is $(st, loc)$, where $st$ is an $\mathbf{assume}$ statement in trace $t$ that violates the requirements of early assumes, and $loc$ is the location before which $st$ should be placed to for fixing the violation. $\mathcal{E}_t$ will be used later for calculating the semantic transitions of $t$.

The feasibility checking is based on calculating the semantic transitions of $t'$ \cite{POPL19,fm}. Each state $S$ is a tuple $(E, D, F)$, where $E$ defines the equality relation between the program variable, $D$ is the disequality relation between the program variables, and $F$ is the function definition (or relation) between variables. The initial state is the one in which only $E$ is the identity relation (dented by $\mathit{ID}$) of the program variables (Line 3). If both of $S$'s $E$ and $D$ contain $(x, y)$, \emph{i.e.}, $x$ is both equal to and not equal to $y$, $S$ is inconsistent (denoted by $\mathsf{Inconsistent}(S)$), and the trace is infeasible.

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{minipage}{0.55\textwidth}
	\vspace{-1.5cm}
	\begin{algorithm}[H]
	\caption{$\mathsf{Feasible}(t)$}
		\label{alg:feasible}
		\begin{algorithmic}[1]
			\REQUIRE A counter-example trace $t = \langle st_1, ..., st_n\rangle$.
			\ENSURE $t$'s feasibility and transitions.
			\STATE $t' \gets \mathsf{Coherent}(t)$
			\STATE $\mathcal{E}_{t} \gets \mathsf{EarlyAssume}(t')$
			\STATE $S_0 \gets (\mathit{ID}, \emptyset, \emptyset)$
			\FOR{each $1 \leq i \leq \mathsf{len}(t')$}
				\STATE $S_i \gets \mathsf{Trans}(S_{i-1}, st_i, \mathcal{E}_t)$
				\STATE $S_i \gets \mathsf{Compact}(S_i)$
				\STATE $T \gets T \cup \{(S_{i-1}, st_i, S_{i})\}$
				\IF{$\mathsf{Inconsistent}(S_i)$}
					\RETURN $(\mathsf{False}, T)$
				\ENDIF
			\ENDFOR
			\RETURN $(\mathsf{True}, T)$
		\end{algorithmic}
	\end{algorithm}
	\vspace{-1.3cm}
	\end{minipage}
	\end{wrapfigure}

For each statement $st_i$, the algorithm calculates the transition with respect to the semantic definitions \cite{fm} (Line 5), where $\mathcal{E}_t$ will be used to update the states \emph{w.r.t.} the relations defined in the $\mathbf{assume}$ statements that violating the early assume requirements. Specifically, if there exists an element $(\mathbf{assume}(e), loc)$ in $\mathcal{E}_t$ and $st_i$ is just after $loc$, the relation $e$ will be used to update the state before $st_i$. After calculating each statement's transition, the resulted state $S_i$ will be checked to remove the redundant information (Line 6) caused by the ghost variables added for coherence.
If a ghost variable $g$ is not defined by or equal to any other variable \emph{w.r.t.} to $F$ or $E$, the relations in $F$ defined by $g$ are redundant because removing them does not lose any information.
Hence, $\mathsf{Compact}(S_i)$ is defined as follows, where $S_i = (E, D, F)$, $\mathcal{G}$ is the set of all the ghost variables, and $E[g]$ represents the equivalence set of $g$ \emph{w.r.t.} $E$.
\begin{equation}\label{compact}
(E, D, F \setminus \{(g, x) \in F \mid g \in \mathcal{G} \wedge \#E[g] = 1 \wedge \forall (i, o) \in F \bullet o \neq g\})
\end{equation}

\vspace{-0.3cm}

Algorithm \ref{alg:generalize} shows the trace abstraction based on the transitions calculated in feasibility checking in case of the trace is infeasible. The key idea is to remove the transition caused by ghost statements and merge two states if they are equal. The algorithm first adds all the transitions caused by non-ghost statements into the FSA $\mathcal{A}_t$'s transitions (Line 2). Then, the algorithm connects the states between which only ghost statement transitions exist (Lines 3-4). Finally, the algorithm checks all the different states and merges any two states (Line 5-9) if they are equal. Here, we omit some details due to the space limit, which are removing unreachable states from $\mathcal{A}_t$, adding self-transitions of any statement to the final inconsistent state, and adding self-transitions to the states such that the self-transitions are not related to the inconsistency.

Note that our trace abstraction method optimizes the method in \cite{fm} in two aspects. One is that we employ the fixing information of early assume requirements during feasibility checking (\emph{i.e.} using $\mathcal{E}_t$ at Line 5 in Algorithm \ref{alg:feasible}), which decreases the number of the ghost variables needed for making the trace coherent. The other one is that we remove the redundant function definitions defined by ghost variables ($\mathsf{Compact}(S_i)$ and Definition \ref{compact}). Both of these two optimizations improve the chances of merging state, which results in a more generalized trace abstraction. Hence, our optimizations improve the effectiveness of trace abstraction-based CEGAR procedure by reducing the iterations of refinements, which is also demonstrated by evaluation results in Section \ref{sec:eff}.

%The trace abstraction method is critical for refining $\mathcal{A}_{\mathcal{P}}$ and extending $\mathcal{A}_{C}$. The method proposed by Hong \emph{et al.} \cite{fm} adds \emph{ghost} variables to convert a non-coherent trace into a coherent trace, which may introduce redundant information into trace abstraction and limit the generalization ability.
%ignores the different reasons why the trace violates \emph{coherence} and introduces redundant information on trace abstraction.
%We give several insights to propose a more fine-grained abstraction method.

\vspace{-0.5cm}

\begin{algorithm}[H]
\caption{$\mathsf{Generalize}(T)$}
	\label{alg:generalize}
	\begin{algorithmic}[1]
		\REQUIRE An infeasible trace $t$'s transitions: $S_0 \rightarrow_{st_1} S_1 \rightarrow ... \rightarrow_{st_m} S_m$, where $t = \langle st_1, ..., st_n\rangle$, $S_m$ is inconsistent and $m \leq n$.
		\ENSURE FSA $\mathcal{A}_t$ that accepts infeasible traces with the same reason of $t$.
		\STATE $\mathcal{A}_t = (\{st_1, ..., st_n\}, \{S_0, ..., S_m\}, T, S_0, S_m)$
		\STATE $T \gets \{(S_i, st_{i+1}, S_{i+1}) \mid 0 \leq i \leq m-1 \wedge st_{i+1}\ is\ not\ a\ ghost\ statement\}$
		\STATE $R \gets \{(S_i, st, S_j) \in T \mid st_{j+1}\ is\ a\ ghost\ statement\}$
		\STATE $T \gets (T \cup \{(S_i, st_1, S_k) \mid (S_i, st_1, S_j) \in R \wedge k = \displaystyle \arg \min_{k > j} (S_k, st_2,S_{k+1} ) \in T\}) \setminus R$
%		\FOR{$ S_i, S_j \in \{S_0, ..., S_m\} \wedge i \neq j$}
%				\IF {$j = i + 1 \wedge st_{i+1}\ is\ a\ ghost\ statement$}
%          \STATE $T \gets T \setminus \{(S_i, st_{i+1}, S_j)\}$
%        \ENDIF
%    \ENDFOR
		\FOR{$ S_i, S_j \in \{S_s, S_t \mid (S_s, st, S_t) \in T\} \wedge i \neq j$}
        \IF {$S_i = S_j$}
          \STATE $T \gets T \cup \{(S_i,{\bf skip},S_j)\}$
        \ENDIF
    \ENDFOR
    \RETURN $\mathcal{A}_t$ \textcolor{gray!50}{// $\mathcal{A}_t$'s unreachable states are removed.}
	\end{algorithmic}
\end{algorithm}

%\begin{itemize}
%    \item First, we notice that the violation of \emph{early assumes} can be fixed by instrumenting
%    the corresponded assume statement other than adding ghost variables,
%    which avoids the introduction of redundant information.
%    \item Second, we notice that the violation of \emph{memoizing} needs to be fixed by introducing ghost variables.
%    But there is a valid scope for these ghost variables during the trace execution.
%    We can find such valid scope to relieve the burden brought by redundant information.
%    \end{itemize}
%
%For example, an infeasible non-coherent trace is shown below:
%    \begin{align*}
%    & x := t \fatsemi y := k \fatsemi x := f(x) \fatsemi y := f(y)  \fatsemi  x := f(x) \fatsemi y := f(y) \fatsemi
%    \\&  x := f(x) \fatsemi x := f(x) \fatsemi  y := f(y)  \fatsemi  y := f(y)  \fatsemi  \mathbf{assume}(t = k)  \fatsemi \mathbf{assume}(x != y)
%    \end{align*}
%
%Non-coherent indicates that the information about some computed items is lost. We need to complete the information
%on this trace to capture the reasons for infeasibility and generalize it to get an abstract automaton.
%With the method of Hong \emph{et al.}\cite{fm}, because of the redundant information, we cannot merge states that are
%equivalent, so the abstract automata obtained accept only the above trace.
%According to our method, there are two steps to complete the information on the states.
%
%First, we complete the information lost by violating \emph{early assumes}.
%In this trace, the statement $\mathbf{assume}(t=k)$ violates the \emph{early assumes} property
%and the location after the statement $y:=k$ where $t$ and $k$ are defined and no longer modified that we can
%instrument to. We execute the assume statement that violates \emph{early assumes} in advance to complete
%the information lost.
%
%Second, due to the insertion of auxiliary statements, the information lost by violating \emph{memoizing}
%has been completed. Because of the valid scope of the ghost variables $i.e.$
%start at the state that the item saved by the ghost variable first computed and end at the state that the item
%last computed, we eliminate the redundant information of ghost variables. In this trace,
%$g_0$'s valid scope is $g_0:=x;x:=f(x);y:=f(y);$ , so we eliminate the redundant information on other states.
%
%Finally, we get a sequence of states that can capture the reasons for infeasibility,
%and then we merge the equivalent states to get the abstract automata.
%The traces that are accepted by the automata as shown below,
%where * represents 0 or n occurrences of this program fragment.
%And the detail of the algorithm can be seen in Appendix A.
%
%\begin{align*}
%& x := t \fatsemi y := k \fatsemi x := f(x) \fatsemi y := f(y)  \fatsemi  x := f(x) \fatsemi y := f(y) \fatsemi  \\ & {\left[ x := f\left(x\right)  \fatsemi   x := f\left(x\right) \fatsemi y := f\left(y\right) \fatsemi y := f\left(y\right) \fatsemi \right]}^{*} \mathbf{assume}(t = k)  \fatsemi \mathbf{assume}(x != y)
%\end{align*}


%**************************************************************************************************************************************
%  \subsection{Trace Abstraction}
% Usually, a better trace abstraction method that generalizes a trace to more infeasible traces is appreciate since
% it play a critical role in refining $\mathcal{A}_{\mathcal{P}}$ and extending $\mathcal{A}_{C}$.
% Compare with the abstraction method proposed in \cite{fm},  we give several insights to propose a more
% fine-grained abstraction method.


% %$\\$
% %泛化方法的说明   介绍 fm 中的方法
% % \noindent
% % {\bf Trace Abstraction in \cite{fm}:} Given an infeasible non-coherent trace like below, we use the abstraction method proposed in \cite{fm} to generalize such trace and construct the automata accepting infeasible traces.
% % \[
% % \begin{aligned}
% % x := y \fatsemi z := x \fatsemi x := f(x) & \fatsemi  y := f(y) \fatsemi x := f(x) \fatsemi \\ y := f(y) \fatsemi  z := f(z) & \fatsemi \mathbf{assume}(x != y)
% % \end{aligned}
% % \]


% % First, the trace is not coherent and we need to add ghost variables \cite{POPL19} to make it coherent as shown below:

% % \[
% % \begin{aligned}
% % x := y \fatsemi z := x \fatsemi x := &f(x)  \fatsemi  y := f(y) \fatsemi x := f(x) \fatsemi \\  g_0 := y \fatsemi y := f(y) & \fatsemi  z := f(z)  \fatsemi \mathbf{assume}(x != y)
% % \end{aligned}
% % \]

% % Then we construct an automata which accepts only the above trace and its states are the tuples about variable relationship like $(E,D,F)$, $E$ is the equality relation, $D$ is the dis-equality relation and $F$ is the set of function definitions, For more
% % details can be refer to \cite{fm}. Based on the variable relationship, we do the abstraction process and obtain the final abstracted automata accepts only the above trace, because there is no equivalent states \footnote{Two states $S_i$ and $S_j$ are equivalent $iff$ they have
% % the same $E$, $D$ and $F$} that repeats in the tuple sequence, it can be generalized out of the loop.

% % Note that, the infeasibility of this trace is due to the relationship between $x$ and $y$, while the non-coherence is caused by variable $z$ which has nothing to do with $x$ and $y$. The analysis implies the non-coherence does not affect the infeasibility of this trace and the information brought by $g_0$ is useless for abstraction. Actually the abstraction method in \cite{fm} does not concern the influence of non-coherence on the infeasibility in detail. Here, we consider such influence in a more granular way to improve the effectiveness of trace abstraction method based on two insights:

% % \begin{itemize}
% % \item the usage of ghost variables may bring \emph{useless} information for the infeasible reasoning of the trace $t$.
% % \item the usage of ghost variables may bring \emph{useful but redundant} information for the infeasible reasoning of the trace $t$.
% % \end{itemize}



% % \begin{algorithm}[!t]
% % \caption{$trace\_generalization$}
% % \label{fig:gen_all}
% % \begin{algorithmic}[1] %每行显示行号
% % 	\REQUIRE The trace $t$
% % 	\ENSURE  The empty automata $\mathcal{A}_\emptyset$ or the non-empty automata $\mathcal{A}_t$
% % 	\IF {$\neg feasibility\_checker(t)$}
% % 	    \STATE $\mathcal{A}_t \leftarrow generalize\_method(t)$
% % 	\ELSE
% %     	\IF {$early\_assume\_violation(t)$}
% %     		\STATE $t \leftarrow assume\_move\_ahead(t)$
% %     	\ENDIF
% %     	\IF {$memoizing\_violation(t)$}
% %     		\STATE $t \leftarrow information\_elimination(t)$
% %     	\ENDIF
% %     	\IF {$feasibility\_checker(t)$}
% %     		\RETURN $\mathcal{A}_\emptyset$
% %     	\ELSE
% %     		\STATE $\mathcal{A}_t \leftarrow generalize\_method(t)$
% %     		\RETURN $\mathcal{A}_t$
% %     	\ENDIF
% %     \ENDIF
% % \end{algorithmic}
% % \end{algorithm}

% %状态合并的算法
% % \begin{algorithm}[!t]
% % \caption{$\mathsf{StateMerge}(t,S\_sequence)$}
% % \label{alg:gen1}
% % \begin{algorithmic}[1] %每行显示行号
% % 	\REQUIRE an infeasible trace $t$:$<stmt_0,\cdots,stmt_n>$  and t's transitions (or modified) $S_0\to S_1\to \cdots \to S_{n+1}$
% % 	\ENSURE  the generalization automata $\mathcal A_t=(\Sigma,S,S_I,S_F,T)$
% % 	\STATE $\Sigma=\{stmt_0,\cdots,stmt_n\} $
% % 	\STATE $ S_I=S_0,S_F = \emptyset,S = \{S_I\}, T = \emptyset$
% % 	\FOR{$i=0 \ to \  n $}
% %             \IF{$ \exists S_j \in S \ \& \ S_j \equiv S_{i+1} $}
% %               \STATE{$T \gets \{S_i,stmt_i,S_j\}\cup T$}
% %             \ELSE
% %               \STATE{$T \gets \{S_i,stmt_i,S_{i+1}\}\cup T$}
% %               \STATE{$S \gets \{S_{i+1}\}\cup S$}
% %               \IF{$is\_conflict(S_{i+1})$}
% %                   \STATE{$S_F \gets \{S_{i+1}\}\cup S_F $}
% %                     \FOR{$stmt\ in\ \Sigma $}
% %                         \STATE{$T \gets \{S_{i+1},stmt,S_{i+1}\}\cup T$}
% %                     \ENDFOR
% %                     \STATE $\mathcal A_t \gets (\Sigma,S,S_I,S_F,T) $
% %                     \RETURN $\mathcal A_t $
% %               \ENDIF
% %             \ENDIF
% %         \ENDFOR
% % \end{algorithmic}
% % \end{algorithm}


% \begin{definition}
%     Given an uninterpreted program $\mathcal{P}$ and its variable set $V$, a term state $S$ is defined as a triple $(E, D, F)$, where
%     \begin{itemize}
%     \item $E \subseteq V \times V$ is the equality relation, and we use $[V]_{E}
%     \subseteq 2^{V}$ to represent the set of $V$'s equivalent classes w.r.t. $E$.
%     \item $D \subseteq [V]_{E} \times [V]_{E}$ is the dis-equality relation.
%     \item $F$ is the set of function definitions, and each function
%     $f:[V]_{E}\times \ldots \times [V]_{E} \rightarrow [V]_{E}$ defines a relation between equivalent variable classes w.r.t. $E$.
%     \end{itemize}
% \end{definition}

% We use $[x]_E$ to represent $x$'s equivalent variable class \emph{w.r.t.} $E$. A state $S = (E, D, F)$ is \emph{inconsistent} when the following condition holds.
% \begin{equation}
% \exists x, y\in V \bullet (x, y) \in E \wedge ([x]_E, [y]_E) \in D
% \end{equation}
% Two states $S_1$ and $S_2$ are equivalent (denoted by $S_1 \equiv S_2$) if they have the same $E$, $D$ and $F$.
% A term state is an abstraction of the program state and the transition rules for the states can be referred to \cite{fm}.
% So if the term state is \emph{inconsistent} indicates that the trace is infeasible, on the other hand, the trace is infeasible
% but the term states are not \emph{inconsistent},
% we discuss these two cases separately and generate different abstraction strategys.

% \noindent
% If the term state can capture the reason why the trace is infeasible, $i.e.$ \emph{inconsistent},
% no matter whether the trace is coherent or not,
% we can merge the equivalent states and obtain the abstracted automata accept more infeasible traces.
% % In the previous example, we abstract the trace according to the method in \cite{fm}, and the automata obtained only accepts the original trace, we noticed that even without the ghost variable, the tuples can capture the reason why the trace is infeasible. Without the relation of $g_0$, we can see that the state after execute $ x:=y $ is equivalence with the state after execute $x:=y;z:=x;x:=f(x);y:=f(y);x:=f(x);y:=f(y)$
% % are ($E:(x,y), D:(), F:()$) \footnote{We omit the equality relation of the variables itself}
% % , so we can merge this two states and the traces that can be abstracted are as shown blow:

% % \begin{align*}
% % %%\begin{aligned}
% % x &:= y \fatsemi{\left[ z := x \fatsemi x := f\left(x\right)  \fatsemi  y := f\left(y\right) \fatsemi x := f\left(x\right) \fatsemi y := f\left(y\right) \fatsemi \right]}^{*} \\ z &:= f\left(z\right) \fatsemi \mathbf{assume}\left(x != y\right)
% % %%\end{aligned}
% % \end{align*}

% In another situation, the original states cannot capture the reason why the trace is infeasible,
% we complete the information in states through the following operations and the corresponding algorithm is presented in Algorithm \ref{alg:gen}.


% \begin{itemize}
% \item First, we notice that the violation of \emph{early assumes} can be fixed by instrument
% the corresponded assume statement other than adding ghost variables,
% which avoids the introduction of redundant information.
% \item Second, we notice that the violation of memoizing need to fix by introducing ghost variables.
% But there is a valid scope for these ghost variables during the trace execution.
% We can find such valid scope to relieve the burden brought by redundant information.
% \end{itemize}


% \begin{algorithm}[!ht]
% \caption{$\mathsf{Generalize}(t)$}
% \label{alg:gen}
%         \begin{algorithmic}[1] %每行显示行号
%             \REQUIRE an infeasible trace
%             $t$=$<stmt_0,\cdots,stmt_n>$
%             \ENSURE  the generalized automata  $\mathcal{A}_t$ that accepts infeasible traces.
%                 \STATE \textcolor{gray!50}{// Automata initialization, $\Sigma = \emptyset, S = \emptyset, T= \emptyset, S_I = S_0,  S_F = \emptyset $}
%                 % \STATE $V \gets \mathsf{getVariables}(t')$  \textcolor{gray!50} {// Get variables of the trace. }
%                 \STATE $\mathcal{A}_t = (\Sigma, S, T, S_I, S_F)$

%                 \STATE \textcolor{gray!50}{// Automata construction.}
%                 \STATE $t' \gets \mathsf{makeTraceMem}(t), V_{t'} \gets \mathsf{getVariables}(t') $ \label{alg:mem}
%                 % \STATE $V_{t'} \gets \mathsf{getVariables}(t')$
%                 \STATE $assume\_instrument \gets \mathsf{earlyAssumesAnalysis}(t') $
%                 \label{alg:ear} \textcolor{gray!50} {// It maps the location to the assume statement should be instrumented. }
%                 % \STATE $ghost\_scoop\_map \gets \mathsf{getGhostScoop}(t\_mem)  $
%                 % \textcolor{gray!50} {// Key: the ghost variable. Value:the valid scoop of the ghost variable. }

%                 \FOR{$i=0 \  to \ length(t')-1$}
%                     \STATE \textcolor{gray!50}{//Completion of information that lost by violate early assumes. }
%                     \STATE $S_{i+1} \gets \mathsf{stateUpdate}(S_i,t'[i] ) $ \label{alg:comp_start}
%                     \IF{$i \in assume\_instrument.key()$} \label{alg:ear_start}
%                        \STATE $S_{temp} \gets \mathsf{stateUpdate}(S_i,assume\_instrument[i])  $ \label{alg:ear_comp}
%                        \STATE $V_s \gets \mathsf{getVariables}(assume\_instrument[i]) $
%                        \STATE $S_{i+1} \gets  S_{i+1} \uplus S_{temp} \downarrow_{V_{t'} \setminus V_s} $ \label{alg:ear_elim}
%                     %   \textcolor{gray!50} {// $S_i \uplus S_j \equiv (S_i.E \cup S_j.E, S_i.D \cup S_j.D, S_i.F \cup S_j.F )$ }
%                     \ENDIF  \label{alg:ear_end}
%                     \STATE $ S \gets  S \cup \{S_{i+1}\} $
%                     \STATE \textcolor{gray!50}{//Completion of information that lost by violate memoizing. }
%                     \IF {$\mathsf{containGhost}(t'[i])$ }  \label{alg:isAuxi_s}
%                         \STATE $ S \gets  S \setminus \{S_{i}\} $
%                         \STATE $ T \gets T \setminus \{( S_{i-1}, t'[i-1], S_i)\}\cup \{ (S_{i-1}, t'[i-1], S_{i+1}) \}$

%                     \ELSE
%                         \STATE $ \Sigma \gets  \Sigma \cup \{t'[i]\} $
%                         \STATE $ T \gets T \cup \{ (S_i, t'[i], S_{i+1}) \}$
%                     \ENDIF \label{alg:isAuxi_e}

%                 \ENDFOR  \label{alg:comp_end}
%             \STATE $ S_F \gets S_{n+1} $

%             \STATE \textcolor{gray!50}{// Eliminate redundant information of ghost variables.}
%             \STATE $V_G \gets  \mathsf{ghostVariables}(t') $
%             \STATE $ghost\_valid\_scope \gets \mathsf{memoizingAnalysis}(V_G , \mathcal{A}_t) $ \label{alg:scope} \textcolor{gray!50} {// It maps the ghost variable to its valid scope. }
%             \FOR{$ S_i \in S$} \label{alg:elim_s}
%                 \FOR {$v_g \  \in \  V_G $}
%                     \IF {$ S_i  \  \notin \  ghost\_valid\_scope[v_g] $}
%                         \STATE $S_i \leftarrow S_i \downarrow_{V_{t'} \setminus v_g} $
%                     \ENDIF
%                 \ENDFOR
%             \ENDFOR  \label{alg:elim_e}
%             \STATE \textcolor{gray!50}{// Automata generalization.}
%             \FOR{$ S_i, S_j \in S$} \label{alg:gen_s}
%                 \IF {$S_i \equiv S_j$}
%                     \STATE $T \gets T \cup \{(S_i,{\bf skip},S_j)\}$
%                 \ENDIF
%             \ENDFOR \label{alg:gen_e}
%             \RETURN $\mathcal{A}_t$
% \end{algorithmic}
% \end{algorithm}


% For example, we have an infeasible non-coherent trace as shown below:
% \begin{align*}
% & x := t \fatsemi y := k \fatsemi x := f(x) \fatsemi y := f(y)  \fatsemi  x := f(x) \fatsemi y := f(y) \fatsemi \\&  x := f(x) \fatsemi x := f(x) \fatsemi  y := f(y)  \fatsemi  y := f(y)  \fatsemi  \mathbf{assume}(t = k)  \fatsemi \mathbf{assume}(x != y)
% \end{align*}

% We need to complete information of this trace to capture the reasons of infeasibility and generalize it to get an abstract automata.
% According to the method in \cite{POPL19}, we can know that trace violate the \emph{early assumes} property
% in the statement $\mathbf{assume}(t=k)$, if we instrument the statement $\mathbf{assume}(t=k)$
% to the location early enough, the trace is still violate the \emph{memoizing} property.
% So there are two steps  to complete the information in the states.
% Above all, we make this path satisfy \emph{memoizing} (Line \ref{alg:mem}) by add auxiliary statements
% and the modified trace as shown below:

% \begin{align*}
% & x := t \fatsemi y := k \fatsemi x := f(x) \fatsemi y := f(y)  \fatsemi  x := f(x) \fatsemi y := f(y) \fatsemi  x := f(x) \fatsemi \\ & g_0 := x  \fatsemi x := f(x)  \fatsemi  y := f(y)  \fatsemi  y := f(y)  \fatsemi   \mathbf{assume}(t = k)  \fatsemi \mathbf{assume}(x != y)
% \end{align*}


% First, according to Line \ref{alg:ear_start} $\sim$ \ref{alg:ear_end}, we complete the informations lost by violate \emph{early assumes}.
% In this trace, the statement $\mathbf{assume}(t=k)$ violate the \emph{early assumes} property
% and the location after the statement $y:=k$ where $t$ and $k$ are defined and no longer modified that we can
% instrument to. In line \ref{alg:ear_start}, we arrive at this location and in line \ref{alg:ear_comp}
% we execute the assume statement that violate \emph{early assumes} in advance to complete the information lost.
% We only need the information due to the equivalence of $t$ and $k$, so in line  \ref{alg:ear_elim},
% we remove the redundant information about $t$ and $k$ themselves
% where $S_i \uplus S_j = (S_i.E \cup S_j.E, S_i.D \cup S_j.D, S_i.F \cup S_j.F )$.


% Second, due to the auxiliary statements we inserted, the informations lost by violate \emph{memoizing}
% have been completed. In Line \ref{alg:isAuxi_s} $\sim$ \ref{alg:isAuxi_e}, we avoid the redundant
% states generate by the auxiliary statements. And then, because of the valid scope of the ghost variable $i.e.$
% start at the state that the item saved by the ghost variable first computed and end at the state that the item
% last computed (Line \ref{alg:scope}), we eliminate the redundant information of ghost variables
% (Line \ref{alg:elim_s} $\sim$ Line \ref{alg:elim_e}). In this trace, $g_0$'s valid scope is
% $g_0:=x;x:=f(x);y:=f(y);$ , so we eliminate the redundant information in other states.


% Finally, we get a sequence of states that can capture the reasons of infeasibility,
% and then we merge the equivalent states (Line \ref{alg:gen_s} $\sim$ \ref{alg:gen_e}) to
%  get the abstracted automata. The traces that accepted by the automata as shown blow.

% \begin{align*}
% & x := t \fatsemi y := k \fatsemi x := f(x) \fatsemi y := f(y)  \fatsemi  x := f(x) \fatsemi y := f(y) \fatsemi  \\ & {\left[ x := f\left(x\right)  \fatsemi   x := f\left(x\right) \fatsemi y := f\left(y\right) \fatsemi y := f\left(y\right) \fatsemi \right]}^{*} \mathbf{assume}(t = k)  \fatsemi \mathbf{assume}(x != y)
% \end{align*}
%**************************************************************************************************************************************************************